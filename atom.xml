<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zsybh1.github.io</id>
    <title>zsybh1&apos;s Blog</title>
    <updated>2021-05-23T02:48:25.943Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zsybh1.github.io"/>
    <link rel="self" href="https://zsybh1.github.io/atom.xml"/>
    <subtitle>没什么好看的XD</subtitle>
    <logo>https://zsybh1.github.io/images/avatar.png</logo>
    <icon>https://zsybh1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zsybh1&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[ Windows Vcpkg+Cmake环境配置]]></title>
        <id>https://zsybh1.github.io/post/windows-vcpkgcmake-huan-jing-pei-zhi/</id>
        <link href="https://zsybh1.github.io/post/windows-vcpkgcmake-huan-jing-pei-zhi/">
        </link>
        <updated>2021-05-23T02:46:27.000Z</updated>
        <content type="html"><![CDATA[<p>近期有使用各种第三方库进行C++开发的需求，鉴于以前有过自己编译第三方库的经历，遇到了不少问题，花了很多时间才解决，于是这次就考虑学习使用包管理工具vcpkg</p>
<h2 id="安装">安装</h2>
<p>vcpkg的使用需要VS2015Update3以上，且必须安装<strong>英文语言包</strong>，如果没有需要在vs_installer中进行安装，否则后面vcpkg使用时会出错</p>
<p>在powershell中执行以下指令</p>
<pre><code class="language-bash"># 下载源文件
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
# 安装
.\bootstrap-vcpkg.bat
</code></pre>
<p>为了使用上的方便，可以考虑在系统变量中增加一个条目指向vcpkg的目录（如VCPKG_DIR），然后在PATH中引用它</p>
<p>执行集成指令：</p>
<pre><code class="language-bash">vcpkg integrate install
</code></pre>
<p>这个命令执行后，所有VS原生的C++项目都可以像使用标准库一样使用第三方库。注意这句话执行后下面会跳出来一句</p>
<pre><code class="language-bash">CMake projects should use: &quot;-DCMAKE_TOOLCHAIN_FILE=(your path to vcpkg)/scripts/buildsystems/vcpkg.cmake&quot;
</code></pre>
<p>复制这个路径，后面使用Cmake时会需要用到</p>
<p>如果不想集成vcpkg到所有vs工程，可以使用</p>
<pre><code class="language-bash">vcpkg integrate remove
</code></pre>
<p>来取消集成。如果此时想要用到vcpkg的库，可以使用</p>
<pre><code class="language-bash">vcpkg integrate project
</code></pre>
<p>来集成到特定的项目，具体操作并没有进行尝试，而且也不是本文的重点</p>
<h2 id="用vcpkg管理第三方包">用vcpkg管理第三方包</h2>
<p>查找第三方包</p>
<pre><code class="language-bash">vcpkg search [package_name]
</code></pre>
<p>安装第三方包：</p>
<pre><code class="language-bash">vcpkg install &lt;package_name&gt;[:triplet]
# 例
vcpkg install opencv:x64-windows
</code></pre>
<p>注意这个triplet，可以使用<code>vcpkg help triplet</code>查看所有支持的架构。如果不填写架构，在windows上默认安装的是x86-windows，这是适用于msvc编译器和32位程序的架构，如果想要64位，或者想用比如mingw编译器开发，就需要指定别的架构，如x64-mingw-static</p>
<p>移除第三方包：</p>
<pre><code class="language-bash">vcpkg remove &lt;package_name&gt;[:triplet]
</code></pre>
<p>查看所有安装的第三方包</p>
<pre><code class="language-bash">vcpkg list
</code></pre>
<p>更多的操作可以自行查看vcpkg的命令列表</p>
<h2 id="在vs的cmake项目中使用vcpkg">在VS的Cmake项目中使用vcpkg</h2>
<p>一个使用vcpkg的CmakeLists.txt范例</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10)

# 如果没有定义环境变量，把路径写全，也可以用前面集成时复制的那一句
set(CMAKE_TOOLCHAIN_FILE &quot;$ENV{VCPKG_DIR}/scripts/buildsystems/vcpkg.cmake&quot;)

project(main)

set(CMAKE_CXX_STANDARD 17)

find_package(OpenCV REQUIRED)

include_directories(&quot;$ENV{VCPKG_DIR}/installed/x64-windows/include&quot;)

add_executable(main main.cpp)
target_link_libraries(main PRIVATE ${OpenCV_LIBS})
</code></pre>
<p>如果前面将vcpkg继承到了vs中，就不需要写set cmake_toolchain_file这一行，vs会自己定位</p>
<p>find_package后面写想要添加的库名字，可以有智能提示，可以用鼠标移上去查看引入这个库需要的其它设置：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zsybh1/ImageBed/master/img/20210523102742.png" alt="image-20210523102733097" loading="lazy"></figure>
<p>其中target_include_directories可以不写，因为vcpkg中所有头文件都在一起，一个include_directories就可以引用到所有头文件</p>
<p>如果find_package报错，提示需要xxxConfig.cmake，那就表明工具链没有被正确设置，检查一下路径是否正确然后项目-Cmake缓存-删除缓存，再重新生成即可</p>
<p>如果需要编译release版本，项目-Cmake设置，新建一个x64-release配置（或者其他release），配置类型改为Release即可</p>
<p>以上工作完成后，就可以愉快地开始写代码了</p>
<h3 id="在vscode的cmake项目中使用vcpkg">在VSCode的Cmake项目中使用vcpkg</h3>
<p>CmakeLists.txt的设置和前面vs一致，注意在vscode中不能删除set cmake_toolchain_file这一行。Cmake的toolkit要选择msvc，如果想使用clang或mingw需要在vcpkg下载包的时候就选择别的架构</p>
<p>VSCode中find_package没有智能提示，所以即使选择在VSCode环境下进行开发也更推荐使用vs进行CmakeLists.txt的编辑</p>
<p>如果出现头文件错误，按F1输入Configuration，找到C/C++Configuration，找到包含路径，将include_directories里的完整路径复制进去即可</p>
<p>如果出现find_package错误，同样是检查toolchain的配置，然后<strong>删除缓存</strong>再重新生成</p>
<p>想要使用Release模式，左下角找到CMake:[Debug]:Ready，点击改成Release即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MASM中的局部变量使用]]></title>
        <id>https://zsybh1.github.io/post/masm-zhong-de-ju-bu-bian-liang-shi-yong/</id>
        <link href="https://zsybh1.github.io/post/masm-zhong-de-ju-bu-bian-liang-shi-yong/">
        </link>
        <updated>2021-05-01T04:49:19.000Z</updated>
        <content type="html"><![CDATA[<p>在masm的子程序中，可以通过local伪指令来定义局部变量。而当局部变量涉及到指针和数组的时候，变量的使用方式会有些许的差别。</p>
<p>对于指针和数组，当我们要取其中的元素的时候，在C中有两种方式：</p>
<pre><code class="language-c">p[i];
*(p+i)
</code></pre>
<p>对应到masm就是：</p>
<pre><code class="language-assembly">p[ecx*4]
[p+ecx*4]
</code></pre>
<p>现在我们定义：</p>
<pre><code class="language-assembly">local vec[5]:dword
local list:ptr dword
</code></pre>
<p>如果我们使用<code>vec[ecx*4]</code>可以正常获得相当于C中<code>vec[i]</code>的值，但是如果向<code>list[ecx*4]</code>进行写入，轻则破坏vec数组的数据，重则破坏栈区结构。</p>
<p>同时我们也会注意到，如果采用下面的方式调用数组数据：</p>
<pre><code class="language-assembly">mov esi, vec
mov edi, list
mov eax, [edi+ecx*4]
add eax, [esi+ecx*4]
</code></pre>
<p>第三句可以正常赋值，第四句却多半会报错</p>
<hr>
<p>实际上，vec，list这种符号本身，是<strong>栈区</strong>对应变量的<strong>地址</strong>。按照正常使用方式，需要<code>[vec]</code>和<code>[list]</code>才能取得栈区的变量本身，但是在masm中，如果符号单独出现，会直接翻译成带中括号形式。例如，上面的1、2句会翻译为</p>
<pre><code class="language-assembly">mov esi, dword ptr [vec]
mov edi, dword ptr [list]
</code></pre>
<p>在这种情况下再分析上面的语句。</p>
<p>vec是一个存放在栈区的数组，所以<code>[vec]</code>对应的就是<code>vec[0]</code>数据本身，而<code>vec[ecx*4]</code>即<code>[vec+ecx*4]</code>本质上就是<code>vec[0]</code>的栈区地址加上<code>ecx*4</code>大小的偏移，可以正常找到<code>vec[i]</code>的数据；而<code>[esi+ecx*4]</code>相当于把<code>vec[0]</code>当做地址，在此基础上加上<code>ecx*4</code>大小的偏移，显然会导致非法访存。</p>
<p>list是一个存放在堆区的数组，<code>[list]</code>的值是放在<strong>栈区</strong>的堆区数组首地址，而<code>list[ecx*4]</code>即<code>[list+ecx*4]</code>表示的是<code>list</code>的<strong>栈区地址</strong>加上<code>[ecx*4]</code>的偏移，显然这个值还是停留在栈区，并且可能破坏栈区的数据。而<code>[edi+ecx*4]</code>中的<code>edi</code>即<code>[list]</code>表示的是堆区数组的首地址，再加上<code>ecx*4</code>并寻址就可以取得<code>list[i]</code>的正确数据。</p>
<hr>
<p>另外这里还有一点要注意，按照定义，<code>mov eax, [[list]]</code>应当可以得到list[0]的值，但是实际使用中这句话依然会被翻译成<code>mov eax, dword ptr [list]</code>，因此还是需要将[list]单独保存在一个寄存器中再取地址</p>
<hr>
<p>综上，当我们在masm中取普通数组和指针数组的元素时，应当以如下的方法</p>
<pre><code class="language-assembly">local vec[5]:dword
local list:ptr dword
...
mov ecx, 3
mov eax, vec[ecx*4]
mov edx, list
add eax, [edx+ecx*4]
</code></pre>
]]></content>
    </entry>
</feed>